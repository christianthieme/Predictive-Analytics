---
title: "Data624 Project 2"
author: "Group 4"
date: "`r Sys.Date()`"
output:
  html_document:
    font-family: Consolas
    highlight: tango
    number_sections: no
    theme: paper
    toc: yes
    toc_depth: 4
    toc_float: yes
  pdf_document:
    toc: yes
  word_document:
    toc: yes
    toc_depth: '4'
---

```{=html}
<style type="text/css">

code {
  font-family: "Consolas";
  font-size: 11px;
}

pre {
  font-family: "Consolas";
  font-size: 11px;
}

mark {
  background-color: whitesmoke;
  color: black;
}

</style>
```
```{r setup, include=FALSE}


options(scipen = 9)
set.seed(101)

library(fpp2)
library(ggplot2)
library(tidyr)
library(dplyr)
library(broom)
library(seasonal)
library(imputeTS)
library(tidymodels)
library(mice)
library(inspectdf)
library(lubridate)
library(corrplot)
library(caret)
library(fpp3)
library(randomForest)
```

<font size="3">Group Members</font>

-   Subhalaxmi Rout
-   Kenan Sooklall
-   Devin Teran
-   Christian Thieme
-   Leo Yi

/pagebreak

## Introduction

We have been given a dataset from a beverage manufacturing company that consists of 2,571 rows of data and 33 columns. The dataset contains information on different beverages and their chemical composition. The goal of this analysis is to use the 32 predictive features to predict the *Potential for hydrogen* (pH), which is a measure of the acidity/alkalinity of the beverage. pH is the key KPI in this analysis. 

We'll begin by reading in the dataset and looking at each column's data type: 

```{r}
train <- readr::read_csv('https://raw.githubusercontent.com/christianthieme/Predictive-Analytics/main/Project2/data/StudentData%20-%20TO%20MODEL.csv')

train$obs_type <- "train"

test <- readr::read_csv('https://raw.githubusercontent.com/christianthieme/Predictive-Analytics/main/Project2/data/StudentEvaluation-%20TO%20PREDICT.csv')

test$obs_type <- "test"

df <- train %>%
  rbind(test) %>%
  filter(!is.na(PH))

# convert column names to all lowercase
names(df) <- lapply(names(df), tolower)

glimpse(df)
```
We see that all columns, with the exception of `brand`, are doubles and continuous. Excluding the response variable, this means that we have 1 categorical variable and 31 continuous variables to work with. 

## Exploratory Data Analysis

In the output above, we can see that there are missing values (NAs). Let's see how pervasive this issue is within our dataset: 

```{r fig.width = 12, fig.height=6}
visdat::vis_miss(df %>% filter(obs_type == 'train'), sort_miss = TRUE)
```

In total, only about 1% of our data is missing. We can see that most of the columns are only missing a negligible amount of data. `mfr` and `brand code` have the largest amount of missing values and are missing 8.25% and 4.67% of their data, respectively. Additionally, there does not appear to be a pattern in which values are missing. Now that we understand that our missing values are not a pervasive issue, we'll continue with our analysis.

#### Distribution of Response Variable: pH

Let's get an understanding of the distribution of our response variable: 

```{r}
df %>% 
  filter(obs_type == 'train') %>%
  select(ph) %>%
  ggplot() + 
  aes(x = ph) + 
  geom_histogram()
```

The distribution of pH is left-skewed and multi-modal. Generally speaking, when we see a multi-modal distribution, often times that is an indication that there are sub-populations within the distribution. We know from looking at our dataset that there is a `brand code` with values A, B, C, and D. Let's break up the above distribution into 4 distributions based on these values: 

```{r fig.height=6, fig.width=10}
df %>% 
  filter(obs_type == 'train') %>%
  #filter(`brand code` == 'A') %>% 
  select(`brand code`, ph) %>%
  ggplot() + 
  aes(x = ph) + 
  geom_histogram() +
  labs(title = "Brand A") + 
  facet_wrap(~`brand code`)
```

Breaking down to this further grain does not seem to be much more helpful. There may be even more granular sub-populations within this data that we are not seeing. 

Now we'll turn our attention to the numeric features within our dataset: 

```{r fig.height=15, fig.width=10}
inspectdf::inspect_num(df %>%  filter(obs_type == 'train') %>% select(-ph)) %>% 
  show_plot()
```

We note the following about these distributions: 

* `air pressurer` - there appears to be either two distributions here, or a single distribution with a pocket of outliers
* `balling`, `balling lvl`, `density`,`fill pressure`, `hyd pressure1`, `hyd pressure2`, `hyd pressure3`, `hyd pressure4`, `mnf flow`, `pressure setpoint`- there appears to be two distributions here. This could potentially be connected to the type of `brand code` or something else not as easily distinguishable. 
* `bowl setpoint` - half of all the values are around 120
* `carb flow` - most values fall between 3,000 and 4,000 with a large pocket of values at 1,000 as well
* `filler speed`, `mfr`, `oxygen filler` - either appears to have two distributions or a few significant outliers
* general note: it appears that many of these distributions are skewed in one way or another. We note that a transformation may be helpful when generating predictions. 

#### Explanatory Variable Relationships with the Response Variable

Now that we've looked at our response variable, let's look at our explanatory variables. We'll begin first by looking at `brand code`, which is our only categorical variable: 

```{r fig.height=5, fig.width=12}
df %>% 
  filter(obs_type == 'train') %>%
  select(`brand code`,ph) %>%
  ggplot() + 
  aes(y = ph) + 
  geom_boxplot()+
  labs(title = 'Brand Code Box Plots') + 
  facet_grid(~`brand code`, scales = 'free_x')
  
```

We can see from the above boxplots that `brand code` does have a meaningful relationship with pH. We can also see some significant outliers in C and possibly D that that will need to be evaluated further. We'll now turn our attention to the numeric features in our dataset.

**Numeric Features**

```{r fig.height=15, fig.width=12, message=FALSE, warning=FALSE}
df %>% 
  filter(obs_type == 'train') %>%
 # data.frame() %>%
  select(-`brand code`, -obs_type) %>% 
  #filter(`brand code` == 'C') %>%
  gather(variable, value, -ph) %>%
  ggplot(aes(x = value, y = ph)) +
  geom_point() +
  facet_wrap(~variable, scales = "free_x") +
  labs(x = element_blank())
```

We note the following about the relationship between pH and these variables: 

* `air pressurer` - it appears that there are two sub-groups here. In looking to see if this was due to `brand code` we found that these sub-groups exist even at individual group levels
* `alch rel` - most points appear to be gathered in 3 distinct areas, however there do appear to be 7 outliers
* `balling`, `balling lvl` - it appears that there are two sub-groups here. These sub-groups do potentially look to be associated with `brand code`
* `bowl setpoint` - appears to potentially be a categorical variable as the values don't appear to be continuous. Also appear to potentially be some outliers
* `carb flow` - appear to be two or three groups of data points. Also note the presence of outliers
* `density` - appear to be two to three groups of points. We note the presence of an outlier
* `filler speed` - appear to mostly fall within the low or high range. Values in the middle are less frequent.
* `pressure setpoint` - appear to be discrete values with the exception of 4 outliers
* `pressure vacuum` - appear to be discrete values with a potentially positive linear relationship. We note the presence of an outlier
* `psc co2` - appear to be discrete values. We note the presence of an outlier
* `psc fill` - there appear to be 5 bands that values can fall into with certain areas that do not have values. We may consider adding a categorical variable to capture this
* `carb pressure`, `carb pressure1`, `carb rel`, `carb volume`, `fill ounces`, `fill pressure`, `filler level`, `hyd pressure1-4`, `mfr`, `oxygen filler`, `pc volume`, `psc`, `temperature`, `usage cont`- no visible relationship. We do note the presence of outliers
* General note: It appears that many of these variables are on different scales. We'll take care of this during our data prep phase. 

**Correlated Features**

For many models, correlation between features can be an issue. Let's see what the correlation between our variables looks like: 

```{r fig.height=12, fig.width=12}
numeric_values <- df %>% filter(obs_type == 'train') %>% dplyr::select_if(is.numeric)
numeric_values <- numeric_values[complete.cases(numeric_values),] %>% data.frame()
train_cor <- cor(numeric_values)
corrplot::corrplot.mixed(train_cor, tl.col = 'black', tl.pos = 'lt')
```

We see many of our features are *highly* correlated. There are several methods we could use to solve this, however, because we have many features, it may make sense to use principal component analysis, which will allow us to reduce the number of columns in our model and hopefully produce a simpler model. 

**Summary EDA Notes**
* Feature distributions are skewed and may benefit from a transformation
* Missing data will most likely not be a significant issue
* There are several outliers in our features - we should think about using a modeling technique that is robust against outliers
* Many of our features are significantly correlated with each other. PCA or another method may be helpful in reducing collinearity
* There appear to be sub-populations even within `brand codes`. It may be helpful to do some feature engineering to tease this information from the data


## Data Processing

#### Dummy Variables

We'll need to transform our categorical feature `brand codes` into a dummy variable: 

```{r}
dmy <- dummyVars(~`brand code`, data = df)
dmy_cols <- predict(dmy, df)

df <- df %>% 
  cbind(dmy_cols) %>%
  select(-`brand code`)
```

#### Data Imputation

Earlier in our analysis, we saw that there were quite a few missing values. Before imputing data, we'll first perform a Yeo-Johnson transformation (similar to BoxCox, but accepts negative values as well), then we'll center and scale the data. Following our transformations, we'll apply principal component analysis in an effort to remove collinearity. Finally, we'll impute our missing values using KNN with 5 nearest neighbors:  

```{r message=FALSE, warning=FALSE}
df_features <- df %>% #filter(obs_type == 'train') %>% 
  select(-ph) %>% 
  data.frame()


trans <- caret::preProcess(
  df_features, 
  method = c("YeoJohnson", "center", "scale", "pca", "knnImpute"), 
  k = 5
  )

df_transformed <- predict(trans, df_features)

#codes <- df %>% filter(obs_type == 'train') %>% select(`brand code`) 

#train_transformed <- train_transformed %>% cbind(codes) 
```



Let's see if we have any missing values in our data now: 

```{r}
colSums(is.na(df_transformed))
```

### Baseline Model

We'll now run a baseline model that will be a starting point to measure all other models against. We've chosen a random forest model because as we noted above, there are outliers within our dataset, and tree methods are often robust against outliers. We are using the default parameters for this initial run: 

```{r}
feature_df <- df_transformed %>% 
  filter(obs_type == 'train') %>% 
  select(-obs_type)

response_df <- df %>% 
  filter(obs_type == 'train') %>% 
  select(-obs_type)


rfModel <- randomForest(feature_df, response_df$ph)
rfModel
```


